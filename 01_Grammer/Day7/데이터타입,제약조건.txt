< DATE - 자료형 >
 
 - 날짜시간타입(datetime)
 - 날짜와 시간을 저장할 수 있는 타입
 - 초단위까지 표현가능
 - 서식문자를 이용하여 년원일, 시분초, 오전/오후등을 표현할 수 있음
 - BC 4712/01/01 ~ 4712/12/31 의 표현범위를 가짐

< TIMESTAMP - 자료형 >
 
 - 날짜시간타입(datetime)
 - DATE 타입의 확장타입
 - 밀리초까지 표현 가능
 - TIMEZONE(시간대) 설정이 들어갈 수 있음
 
 ** sysdate : 현재시간 - DATE타입의 현재 날짜/시간
 ** systimestamp : TIMESTAMP 타입의 현재 날짜/시간
 
< RR,YY의 서식문자 차이 >

 - to_char에서는 아무런 차이가 없다
 - to_date에서는 현재날짜와 관련하여 인식되는 년도가 달라진다

 - YY : 현재 연도에 앞 두자리가 붙는다 ex)2094
 - RR : 현재 연도와 입력한 연도에 따라 달라진다

	현재년도 00~49  -->20XX  -- 현재세기
	과거년도 50~99  -->19XX  -- 이전세기
 	
	ex) 2015년 29/03/02  --> 2029
	    2028년 69/9/13   --> 1969
	    2077년 20/1/2    --> 2120 --다음 세기로간다
	    2099년 94/9/7    --> 2094 --현재 세기

< LONG, 자료형 >
 
 - 가변 길이 문자
 - 최대 길이가 2GB
 - 테이블 당 한 개의 컬럼만 지정할 수 있다
 - 테이블 내에 데이터가 저장된다 
 
< 로렘 입숨, Lorem Ipsum >
 - http://www.lipsum.com/
 - 더미데이터 생성기(테스트용으로 쓰인다)

< 한글 로렘 입숨 >
 -http://hangul.thefron.me/

< LOB, Large Object > 
 
 - 가변길이 타입
 - 최대 4GB까지 저장 가능
 - 테이블에 여러 컬럼으로 지정할 수 있음
 - 참조형으로 동작한다
 - 테이블에는 데이터의 저장 위치만 기록한다
 - 실제데이터는 따로 테이블 밖에 저장한다
 
+ LOB데이터 타입

 - BLOB : 바이너리, Binary --> 이진데이터
	
 - CLOB : 문자, Character --> 문자데이터
	
	+CLOB데이터 조회하기
		-DBMS_LOB객체를 이용한다
		- DBMS_LOB.SUBSTR(col,len,offset)
			col -조회할 LOB컬럼
			len -조회할 데이터의 길이
			offset - 조회가 시작되는 오프셋
	+COLB데이터 전체 조회하기
		
		DBMS_LOB.SUBSTR(col,length(col),1)
		-->첫번째 데이터부터 col컬럼의 길이만큼 조회하기

 - NCLOB : 문자, National Character

< RAW, LONG RAW > -- 쓰지말기 (BLOB쓰세요)
 
 - 바이너리 데이터를 저장한다
 - 이미지나 사운드 같은 바이너리 파일을 저장할 때 사용하는 데이터 타입이다
 - 이진 데이터가 저장되고 조회 시 16진수로 출력된다
 - 문자로 변환할 수 없다



< 스키마, Schema >

 - 데이터베이스의 구조
 - 데이터베이스에 대한 메타데이터
 
 - 개념스키마 : 전체적인 구조
	DB의 전체적인 논리 구조
	개체들의 관계(Relation), 제약조건 등을 나타낸다
	DB에 대한 보안/권한/무결성 등을 정의한 것

 - 내부스키마 :  프로그래머가 바라보는 관점의 데베 구조
	DB의 물리적인 저장구조
	HDD(하드디스크)에 어떻게 저장되어져 있는가
	

 - 외부스키마 : 사용자 관점에서 바라보는 데베 구조
	SELECT를 수행하여 바라보는 DB조회 결과

< 제약사항, Constrains >
 
 - 테이블에 부적적한 데이터가 입력되는 것을 방지하는 목적으로 테이블 컬럼에 설정하는 필터 조건
 - 데이터의 무결성을 유지한다
	**데이터 무결성, Integrity
	프로그램의 생명주기, Life Cycle를 거치는 동안 데이터가 정확하고 일관성있는 값을 유지하고 그 값이 보장되는 성격

	< 제약사항을 지정하는 방식 > --시험
		
	1. CREATE TABLE 구문에 컬럼과 함께 지정하는 방식
	(컬럼 레벨에서 지정하기)
	2. 생성된 TABLE에 ALTER TABLE 구문을 이용하여 추가적으로 반영하는 방식
	(테이블 레벨에서 지정하기)

< 제약사항 종류 >

 -NOT NULL
	컬럼의 데이터로 NULL을 허용하지 않음
	NULL 데이터 입력 할 수 없음
	
	컬럼의 데이터타입과 연계되어 적용되는 제약사항
	ALTER TABLE talbename MODIFY~ 구문을 이용한다

 -UNIQUE
	컬럼에 중복데이터를 허용하지 않는다
	데이터의 유일성을 확보한다
	
	**인덱스를 자동으로 생성한다
	
	UNIQUE가 설정된 컬럼은 테이블의 UNIQUE KEY라고 부른다(유일키, UK)
 -CHECK
 	컬럼에 들어갈 수 있는 데이터의 범위를 지정하는 제약조건
	
	WHERE절의 조건문과 같은 내용을 제약조건으로 적용시킨다
	(search_condition 으로 적용된다)

 -DEFAULT
	데이터를 입력하지 않고 INSERT할 때 입력될 기본값을 지정하는 제약사항 
	NOT NULL처럼 컬럼의 추가 정보로 등록된다
	제약사항 항목으로 부여되지 않는다
	-> user_constraints로 확인할 수 없다
	-> user_tab_column로 확인해야한다(테이블 컬럼정보 자료사전)

 -PRIMARY KEY
	기본키, 주키
	테이블을 대표하는 컬럼으로 지정하는 키
	NOT NULL, UNIQUE 제약사항의 특성이 자동으로 부여됨
	NOT NULL, UNIQUE 가 별도의 항목으로 제약사항이 생성되지는 않는다
	
	PRIMARY KEY 자체가 NOT NULL이며 UNIQUE이다 
	UNIQUE 속성을 가지고 있어서 인덱스가 자동으로 생성된다
	외래키(FK)들이 참조할 수 있는 자격이 부여된다

 -FOREIGN KEY
	외래키, 보조키, 참조키
	기본키(PK)를 참조하는 컬럼 OR 컬럼들
	참조하고 있는 컬럼(기본키)과 데이터 타입이 일치해야 한다.
	
	** 참조 무결성 원칙을 지켜야한다
	: 외래키는 기본키로 존재하는 값을 가져야 한다.
		-> 외래키가 참조하고 있는 기본키는 삭제할 수 없다.
		-> 외래키들을 전부 지우고 기본키를 삭제할 수 있다.
		-> 외래키의 값을 null로 바꿔도됨
	
	** 외래키 지정 구문 마지막에 넣을 수 있는 옵션
	
		ON DELETE SET NULL
		: PRIMARY KEY가 삭제되면 자동으로 NULL로 바뀐다
	
		ON DELETE CASCADE
		: PRIMARY KEY가 삭제되면 자동으로 같이 삭제된다

		아무것도 안적으면 참조무결성을 지킨다.


 < 외래키 지정 방식 >
 - 방법 1 : 컬럼 설정 이후에 CONSTRAINT 로 지정하기
 - 방법 2 : 테이블 생성 후에 ALTER TABLE로 설정하기		
 
 < PK, FK의 관계 >
 
 - 식별관계, Identifying Relationship 	
	FK가 해당테이블에서 PK역할을 수행하는 것
	(FK=PK)
	
 - 비식별관계, Non-Identifying Relationship
	FK가 해당테이블에서 PK역할을 수행하지 않는 것
	(FK!=PK) --추천
























